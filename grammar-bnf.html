<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Backus-Naur Form - CAS CS 320: Principles of Programming Languages</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="grammar-intro.html"><strong aria-hidden="true">2.</strong> Formal Grammar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="grammar-bnf.html" class="active"><strong aria-hidden="true">2.1.</strong> Backus-Naur Form</a></li><li class="chapter-item expanded "><a href="grammar-ambiguity.html"><strong aria-hidden="true">2.2.</strong> Ambiguity</a></li><li class="chapter-item expanded "><a href="grammar-ebnf.html"><strong aria-hidden="true">2.3.</strong> Extended BNF</a></li><li class="chapter-item expanded "><a href="grammar-regular.html"><strong aria-hidden="true">2.4.</strong> Regularity</a></li></ol></li><li class="chapter-item expanded "><a href="parsing.html"><strong aria-hidden="true">3.</strong> Parsing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="parsing-grammar.html"><strong aria-hidden="true">3.1.</strong> Grammars as ADTs</a></li><li class="chapter-item expanded "><a href="parsing-combinators.html"><strong aria-hidden="true">3.2.</strong> Parser Combinators</a></li></ol></li><li class="chapter-item expanded "><a href="semantics.html"><strong aria-hidden="true">4.</strong> Formal Semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semantics-op.html"><strong aria-hidden="true">4.1.</strong> Operational Semantics</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">5.</strong> Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="variables-scoping.html"><strong aria-hidden="true">5.1.</strong> Scoping</a></li><li class="chapter-item expanded "><a href="variables-binding.html"><strong aria-hidden="true">5.2.</strong> Binding</a></li></ol></li><li class="chapter-item expanded "><a href="subprograms.html"><strong aria-hidden="true">6.</strong> Subprograms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="subprograms-ar.html"><strong aria-hidden="true">6.1.</strong> Activation Records</a></li><li class="chapter-item expanded "><a href="subprograms-as.html"><strong aria-hidden="true">6.2.</strong> Activation Stack</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CAS CS 320: Principles of Programming Languages</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="backus-naur-form"><a class="header" href="#backus-naur-form">Backus-Naur Form</a></h1>
<p>Backus-Naur Form (BNF) specifications are used to describe what are called <em>context-free grammars</em>.
Context-free grammars form a class of formal grammars which are sufficiently expressive to capture the grammars of most programming languages.
We will be using BNF specifications to describe the rules which determine well-formed programs in programming languages we aim to interpret.</p>
<p>First, a toy example/thought experiment.
Consider again the following English statement.</p>
<pre><code>the cow jumped over the moon
</code></pre>
<p>Suppose we tried to break down the cognitive process of determining that this sentence is grammatical.
We might first recognize that each word falls into a particular part of speech.
We can represent this step of the process by replacing each word in the sentence with a symbol <em>standing for</em> each figure of speech (the choice of symbol being influenced by what is to come).</p>
<pre><code>&lt;article&gt; &lt;noun&gt; &lt;verb&gt; &lt;prep&gt; &lt;article&gt; &lt;noun&gt;
</code></pre>
<p>We then might recognize some familiar patterns: <code>&lt;article&gt; &lt;noun&gt;</code> captures the determination or quantification of an object, so we might mentally group these symbols (into what grammaticists call <em>nominal phrases</em> or <em>noun phrases</em>) and represent them by a new symbol:</p>
<pre><code>&lt;noun-phrase&gt; &lt;verb&gt; &lt;prep&gt; &lt;noun-phrase&gt;
</code></pre>
<p>Then we might recognize that a preposition followed by a noun phrase is also single unit ("over the moon", "through the woods", and "behind the wall" are examples of <em>prepositional phrases</em>) so that the structure of the entire sentence may be represented as</p>
<pre><code>&lt;noun-phrase&gt; &lt;verb&gt; &lt;prep-phrase&gt;
</code></pre>
<p>Then we might recognize that prepositional phrases can modify verbs, again creating a single unit (e.g., "ran to the car", "arose from bed") leaving us with something like</p>
<pre><code>&lt;noun-phrase&gt; &lt;verb-phrase&gt;
</code></pre>
<p>which we should finally recognize the canonical structure of a well-formed sentence: <em>a thing does a thing.</em>
A bit hand-wavy, but hopefully we can see that this accounts roughly for what we do when we judge that the above sentence is grammatical.</p>
<p>Putting these steps in reverse order (and starting with a single symbol <code>&lt;sentence&gt;</code>, for reasons we will see below) we get something that looks like a <em>proof</em> or <em>evidence</em> that <code>the cow jumped over the moon</code> is a grammatical sentence.</p>
<pre><code>&lt;sentence&gt;
&lt;noun phrase&gt;    &lt;verb phrase&gt;
&lt;noun phrase&gt;    &lt;verb&gt; &lt;prep phrase&gt;
&lt;noun phrase&gt;    &lt;verb&gt; &lt;prep&gt; &lt;noun phrase&gt;
&lt;article&gt; &lt;noun&gt; &lt;verb&gt; &lt;prep&gt; &lt;article&gt; &lt;noun&gt;
the       cow    jumped over   the       moon
</code></pre>
<p>That is, a representation of our congnitive process.
And if we squint, we can see something that hiearchical, something that looks a bit like the parse tree in the introduction to this chapter.</p>
<p><img src="images/parse-tree-2.png" alt="Another parse tree" /></p>
<p>A <em>formal grammar</em> is meant to model this cognitive process of classifying a sentence as grammatical by verifying that it has the "right" hierarchical structure.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>In defining a formal grammar, we have to fix ourselves to a collection of symbols.
These symbols are divided into two disjoint groups: the <strong>terminal symbols</strong> and the <strong>non-terminal symbols</strong>.
In what follows (and as above) we will always notate a non-terminal symbol by something of the form <code>&lt;non-term&gt;</code> (where we replace <code>non-term</code> with something more descriptive) and terminal symbols by sequence of (typically) alphanumeric symbols.</p>
<blockquote>
<p><strong>Remark.</strong> We almost never state outright what the underlying symbols of a grammar are.
It should always be possible to determine what terminal and non-terminal symbols we are considering by looking at the BNF specification itself.</p>
</blockquote>
<p>In the "proof" that we gave that <code>the cow jumped over the moon</code> was grammatical, we built a sequence of not-quite sentences, until the very last one which was an actual sentences. We call these not-quite sentences <em>sentential forms</em>.</p>
<blockquote>
<p><strong>Definition.</strong>
A <strong>sentential form</strong> is a sequence of symbols (terminal or non-terminal).
A <strong>sentence</strong> is a sequence of terminal symbols.</p>
</blockquote>
<p>We notate a sequences of symbols by white space separation.
For example, <code>the dog jumped</code> is a sentence and <code>the &lt;noun&gt; jumped</code> is a sentential form.
But it is important to note that <em>this is just notation</em>.
If it helps, it may be useful to imagine <code>[the, &lt;noun&gt;, jumped]</code> when thinking about what a sentential form is.</p>
<p>In the (reversed) process of building sentential forms, we replaced non-terminal symbols with sentential forms, e.g., we replaced <code>&lt;noun phrase&gt;</code> with <code>&lt;article&gt; &lt;noun&gt;</code>.
A grammar is determined by what replacements we are allowed to do.</p>
<blockquote>
<p><strong>Definition.</strong> A <strong>production rule</strong> is an equation of the form</p>
<pre><code>&lt;non-term&gt; ::= SENTENTIAL-FORM
</code></pre>
<p>where the left-hand side of the <code>::=</code> is a non-terminal symbol, and the right-hand side is a sentential form.</p>
</blockquote>
<p>We read a production rule as saying: "the non-terminal symbol on the left-hand side can be replaced with the sentential form on the right hand side."
In a sense, production rules, <em>define</em> the non-terminal symbols: e.g., a sentence is a noun phrase followed by a verb phrase.</p>
<blockquote>
<p><strong>Definition.</strong> A <strong>BNF specification</strong> is a collection of production rules, together with a designated the <strong>starting symbol</strong>.</p>
</blockquote>
<p>In these notes, the start symbol will be designated as the left-hand side of the <em>first</em> rule appearing in a specification.
The following is an example of a grammar which we will show to <em>recognize</em> the sentence above.</p>
<pre><code>&lt;sentence&gt;    ::= &lt;noun-phrase&gt; &lt;verb-phrase&gt;
&lt;verb-phrase&gt; ::= &lt;verb&gt; &lt;prep-phrase&gt;
&lt;verb-phrase&gt; ::= &lt;verb&gt;
&lt;prep-phrase&gt; ::= &lt;prep&gt; &lt;noun-phrase&gt;
&lt;noun-phrase&gt; ::= &lt;article&gt; &lt;noun&gt;
&lt;article&gt;     ::= the
&lt;noun&gt;        ::= cow
&lt;noun&gt;        ::= moon
&lt;verb&gt;        ::= jumped
&lt;prep&gt;        ::= over
</code></pre>
<p>Note that a non-terminal symbol can have multiple associated production rules.
This is common enough that we have special syntax for this.</p>
<blockquote>
<p><strong>Notation.</strong> We will write</p>
<pre><code>&lt;non-term&gt; ::= SENT-FORM-1 | SENT-FORM-2 | ... | SENT-FORM-n
</code></pre>
<p>as shorthand for</p>
<pre><code>&lt;non-term&gt; ::= SENT-FORM-1
&lt;non-term&gt; ::= SENT-FORM-2
...
&lt;non-term&gt; ::= SENT-FORM-n
</code></pre>
</blockquote>
<p>With this shorthand, we can simply the above grammar:</p>
<pre><code>&lt;sentence&gt;    ::= &lt;noun-phrase&gt; &lt;verb-phrase&gt;
&lt;verb-phrase&gt; ::= &lt;verb&gt; | &lt;verb&gt; &lt;prep-phrase&gt;
&lt;prep-phrase&gt; ::= &lt;prep&gt; &lt;noun-phrase&gt;
&lt;noun-phrase&gt; ::= &lt;article&gt; &lt;noun&gt;
&lt;article&gt;     ::= the
&lt;noun&gt;        ::= cow | moon
&lt;verb&gt;        ::= jumped
&lt;prep&gt;        ::= over
</code></pre>
<p>The last piece of the thought experiment above is the "proof" that the given sentence was grammatical.
We codify this in the notion of a <em>derivation</em>.</p>
<blockquote>
<p><strong>Definition.</strong> A <strong>derivation</strong> of a sentence <code>S</code> in a BNF grammar is a sequence of sentential forms with the following properties:</p>
<ul>
<li>it beginning with the designated start symbol;</li>
<li>it ends in the sentence <code>S</code>;</li>
<li>each sentential form is a the result of replacing <em>one of</em> the non-terminal symbols in the preceding sentence with a sentential form according to a production rule of the grammar.</li>
</ul>
<p>We say that a grammar <strong>recognizes</strong> a sentence <code>S</code> if there is a derivation of <code>S</code> in the grammar.</p>
</blockquote>
<p>A bit of a mouthful, but this essentially restates the process from the thought experiment in a formal way.
That said, it deviates in one way which makes the definition easier to state: in the thought experiment, we allowed ourselves to replace multiple non-terminal symbols simultaneously.
This is not allowed in the above notion of a derivation. A "correct" derivation (correct according to the above definition) would look like:</p>
<pre><code>&lt;sentence&gt;!
&lt;noun-phrase&gt;!     &lt;verb-phrase&gt;
&lt;noun-phrase&gt;      &lt;verb&gt;  &lt;prep-phrase&gt;!
&lt;noun-phrase&gt;!     &lt;verb&gt;  &lt;prep&gt;  &lt;noun-phrase&gt;
&lt;article&gt;  &lt;noun&gt;  &lt;verb&gt;  &lt;prep&gt;  &lt;noun-phrase&gt;!
&lt;article&gt;! &lt;noun&gt;  &lt;verb&gt;  &lt;prep&gt;  &lt;article&gt;  &lt;noun&gt;
the        &lt;noun&gt;! &lt;verb&gt;  &lt;prep&gt;  &lt;article&gt;  &lt;noun&gt;
the        cow     &lt;verb&gt;! &lt;prep&gt;  &lt;article&gt;  &lt;noun&gt;
the        cow     jumped  &lt;prep&gt;! &lt;article&gt;  &lt;noun&gt;
the        cow     jumped  over    &lt;article&gt;! &lt;noun&gt;
the        cow     jumped  over    the        &lt;noun&gt;!
the        cow     jumped  over    the        moon
</code></pre>
<p>For emphasis I've appended an exclamation point to the non-terminal symbol which is replaced at each step (this is <strong>just</strong> for emphasis, they are <strong>not</strong> a part of the derivation, and will not be included in latter derivations).</p>
<p>This derivation also indicates that there are many possible derivations.</p>
<blockquote>
<p><strong>Definition.</strong>
A <strong>leftmost derivation</strong> of a sentence is one in which the leftmost nonterminal symbol is expanded in each step.
A <strong>rightmost derivation</strong> is one in which the rightmost nonterminal symbol is expanded in each step.</p>
</blockquote>
<p>Note that the above derivation is neither the leftmost derivation or the rightmost derivation.</p>
<blockquote>
<p><strong>Exercise.</strong>
Write leftmost and rightmost derivations for the sentence <code>the cow jumped over the moon</code> in the above grammar.</p>
</blockquote>
<h2 id="a-more-interesting-example"><a class="header" href="#a-more-interesting-example">A More Interesting Example</a></h2>
<p>The following is a BNF specification for a fragment of a simple imperative programming language.</p>
<pre><code>&lt;program&gt; ::= &lt;stmts&gt;
&lt;stmts&gt;   ::= &lt;stmt&gt; | &lt;stmt&gt; ; &lt;stmts&gt;
&lt;stmt&gt;    ::= &lt;var&gt; = &lt;stmt&gt;
&lt;var&gt;     ::= a | b | c | d
&lt;expr&gt;    ::= &lt;term&gt; | &lt;term&gt; + &lt;term&gt; | &lt;term&gt; - &lt;term&gt;
&lt;term&gt;    ::= &lt;var&gt; | const
</code></pre>
<p>In English, we would read this specification as:</p>
<blockquote>
<p>A <em>program</em> is a <em>sequence of statements</em>.
A <em>sequence of statements</em> is either a <em>single statement</em>, or a <em>single statement</em> followed a semicolon, followed by a <em>sequence of statements</em>...</p>
</blockquote>
<p>And so on.
This second rule highlights something interesting which we can do in BNF specifications: rules are allowed to be <em>recursive</em>.
The production rule for <code>&lt;stmts&gt;</code> allows us to replace it with a sentential form which <em>contains</em> the non-terminal symbol <code>&lt;stmts&gt;</code>.
This is quite powerful, particularly because it means it is possible to derive an infinite number of sentences in a given grammar.</p>
<blockquote>
<p><strong>Exercise.</strong> Determine the number of sentences that can be derived in the grammar for sentences above (i.e., the number of sentences which can be derived from <code>&lt;sentence&gt;</code>).</p>
</blockquote>
<p>Consider the following program.</p>
<pre><code>a = const ;
a = a + const ;
b = a
</code></pre>
<p>We can verify that this program is recognized by the above grammar by finding a (leftmost) derivation.</p>
<pre><code>&lt;program&gt;
&lt;stmts&gt;
&lt;stmt&gt; ; &lt;stmts&gt;
&lt;var&gt; = &lt;expr&gt; ; &lt;stmts&gt;
a = &lt;expr&gt; ; &lt;stmts&gt;
a = &lt;term&gt; ; &lt;stmts&gt;
a = const ; &lt;stmts&gt;
a = const ; &lt;stmt&gt; ; &lt;stmts&gt;
a = const ; &lt;var&gt; = &lt;expr&gt; ; &lt;stmts&gt;
a = const ; a = &lt;expr&gt; ; &lt;stmts&gt;
a = const ; a = &lt;term&gt; + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = &lt;var&gt; + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = a + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = a + const ; &lt;stmts&gt;
a = const ; a = a + const ; &lt;var&gt; = &lt;expr&gt;
a = const ; a = a + const ; b = &lt;expr&gt;
a = const ; a = a + const ; b = &lt;term&gt;
a = const ; a = a + const ; b = &lt;var&gt;
a = const ; a = a + const ; b = a
</code></pre>
<blockquote>
<p><strong>Remark.</strong> As a reminder, we're not interested in white space when we consider whether or not a sentence is recognized by a grammar.
The choice to present the sentences in three lines was for readability, and the choice to present it in a single line in the derivation was for convenience.</p>
</blockquote>
<p>It may also be worthwhile to point out a feature of the last three four lines of the above derivation: even if a nonterminal symbol is replaced by a <em>single</em> nonterminal symbol in succession, <em>we have to include each step</em>.
We're only allowed to apply one production rule at a time, e.g., we cannot immedatiely replace <code>&lt;expr&gt;</code> with <code>&lt;var&gt;</code> because that is not one of our production rules.</p>
<blockquote>
<p><strong>Exercise.</strong> Does the above program have a rightmost derivation? Why or why not?</p>
</blockquote>
<blockquote>
<p><strong>Exercise.</strong> Verify that</p>
<pre><code>a = a + a ; b = b
</code></pre>
<p>is recognized by the above grammar.</p>
</blockquote>
<h2 id="parse-trees"><a class="header" href="#parse-trees">Parse Trees</a></h2>
<p>Grammars imbue sentences with hierarchical structure.
This structure is represented graphically as a <em>parse tree</em>.
We've seen a couple examples of English grammar parse trees so far, but we can also build parse trees for sentences recognized by <em>any</em> grammar with a BNF specification.</p>
<blockquote>
<p><strong>Definition.</strong> A <strong>parse tree</strong> for a sentence <code>S</code> in a grammar is a (ordered) tree <code>T</code> with the following properties:</p>
<ul>
<li>every leaf of <code>T</code> has a terminal symbol;</li>
<li>every non-leaf node <code>n</code> has a nonterminal symbol (we write <code>val(n)</code> for the value at <code>n</code>);</li>
<li>if a node <code>n</code> with has children <code>[t1, t2, ..., tk]</code> then
<pre><code>val(n) ::= root(t1) root(t2) ... root(tk)
</code></pre>
is a production rule in the grammar (where <code>root(t)</code> denotes the value at the root of the tree <code>t</code>);</li>
<li>The leaves (in order) (i.e., the <em>frontier</em> of <code>T</code>) form the sentence <code>S</code>.</li>
</ul>
</blockquote>
<p>The details of the above definition are not important, as long as you have the right picture in your head.
For example, the sentence <code>a = b + const</code> has the following derivation.</p>
<pre><code>&lt;program&gt;
&lt;stmts&gt;
&lt;stmt&gt;
&lt;var&gt; = &lt;expr&gt;
a = &lt;expr&gt;
a = &lt;term&gt; + &lt;term&gt;
a = &lt;var&gt; + &lt;term&gt;
a = b + &lt;term&gt;
a = b + const
</code></pre>
<p>And has the following parse tree.</p>
<p><img src="images/parse-tree-3.png" alt="A simple parse tree" /></p>
<blockquote>
<p><strong>Exercise.</strong> Given the ADT</p>
<pre><code class="language-ocaml">type 'a tree
   = Leaf of 'a
   | Node of 'a * 'a tree list
</code></pre>
<p>Write the OCaml function <code>frontier</code> which, given</p>
<ul>
<li><code>t</code> : <code>'a tree</code></li>
</ul>
<p>returns the list of leaves of <code>t</code> in order from left to right.</p>
</blockquote>
<p>Every derivation can be converted into a parse tree, and vice versa, but multiple derivations may correspond to the same parse tree.
This will be important when we cover ambiguity in the next section.</p>
<blockquote>
<p><strong>Exercise.</strong> Write a derivation corresponding to the above parse tree when is neither leftmost nor rightmost.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="grammar-intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="grammar-ambiguity.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="grammar-intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="grammar-ambiguity.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
